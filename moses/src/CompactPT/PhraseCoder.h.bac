#ifndef PHRASECODER_H__
#define PHRASECODER_H__

#include <sstream>
#include <vector>
#include <boost/unordered_map.hpp>
#include <boost/unordered_set.hpp>
#include <fstream>
#include <string>
#include <iterator>
#include <algorithm>
#include <sys/stat.h>

#include "TypeDef.h"
#include "FactorCollection.h"
#include "Word.h"
#include "Util.h"
#include "InputFileStream.h"
#include "StaticData.h"
#include "WordsRange.h"
#include "UserMessage.h"

#include "StringVector.h"
#include "Hufftree.h"
#include "ConsistantPhrases.h"

namespace Moses {

template <typename DataType> 
class Counter {
  public:
    typedef boost::unordered_map<DataType, size_t> FreqMap;
    typedef typename FreqMap::iterator iterator;
    typedef typename FreqMap::mapped_type mapped_type;
    typedef typename FreqMap::value_type value_type; 

  private:
    FreqMap m_freqMap;
    size_t m_maxSize;
    std::vector<DataType> m_bestVec;
    
    struct FreqSorter {
      bool operator()(const value_type& a, const value_type& b) const {
        
        if(a.second > b.second)
          return true;
        
        // Check impact on translation quality!
        if(a.second == b.second && a.first > b.first)
          return true;
        
        return false;
      }
    };
  
  public:
    Counter() : m_maxSize(0) {}
    
    iterator begin() {
      return m_freqMap.begin();
    }
    
    iterator end() {
      return m_freqMap.end();
    }
    
    void increase(DataType data) {
      m_freqMap[data]++;
    }
  
    void increaseBy(DataType data, size_t num) {
      m_freqMap[data] += num;
    }
    
    mapped_type& operator[](DataType data) {
      return m_freqMap[data];
    }
    
    size_t size() {
      return m_freqMap.size();
    }
    
    void limitSize(size_t maxSize) {
      m_maxSize = maxSize;
      std::vector<std::pair<DataType, mapped_type> > freqVec;
      freqVec.insert(freqVec.begin(), m_freqMap.begin(), m_freqMap.end());
      std::sort(freqVec.begin(), freqVec.end(), FreqSorter());
      
      for(size_t i = 0; i < freqVec.size() && i < m_maxSize; i++)
        m_bestVec.push_back(freqVec[i].first);
        
      std::sort(m_bestVec.begin(), m_bestVec.end());
      
      FreqMap t_freqMap;
      for(typename std::vector<std::pair<DataType, mapped_type> >::iterator it
          = freqVec.begin(); it != freqVec.end(); it++) {
        DataType closest = lowerBound(it->first);
        t_freqMap[closest] += it->second;
      }
      
      m_freqMap.swap(t_freqMap);   
    }
    
    void clear() {
      m_freqMap.clear();
    }
    
    DataType lowerBound(DataType data) {
      if(m_maxSize == 0 || m_bestVec.size() == 0)
        return data;
      else {
        typename std::vector<DataType>::iterator it
          = std::lower_bound(m_bestVec.begin(), m_bestVec.end(), data);
        if(it != m_bestVec.end())
          return *it;
        else
          return m_bestVec.back();
      }
    }
};

class PhraseCoder {
  private:
    typedef Counter<size_t> SymbolCounter;
    typedef Counter<float> ScoreCounter;
        
    typedef std::pair<unsigned char, unsigned char> AlignPoint;
    //typedef std::pair<size_t, size_t> AlignPoint;
    typedef Counter<AlignPoint> AlignCounter;
    
    typedef std::pair<unsigned, unsigned> SrcTrg;
    typedef std::pair<std::string, std::string> SrcTrgString;
    typedef std::pair<SrcTrgString, float> SrcTrgProb;
    
    bool m_compactEncoding;
    
    bool m_treeForEachScore;
    size_t m_maxScores;
    bool m_containsAlignmentInfo;
    
    size_t m_numScoreComponent;
    
    SymbolCounter m_symbolCount;
    std::vector<ScoreCounter> m_scoreCounts;
    AlignCounter m_alignCount;
    
    typedef std::pair<unsigned, unsigned> SrcTrg;
    std::vector<size_t> m_lexicalTableIndex;
    std::vector<SrcTrg> m_lexicalTable;
  
    StringVector<unsigned char, unsigned, std::allocator> m_sourceSymbols;
    boost::unordered_map<std::string, unsigned> m_sourceSymbolsMap;
    
    typedef std::pair<std::string, std::string> PhrasePair;
    typedef boost::unordered_map<PhrasePair, int> PhrasePairRank;
    typedef boost::unordered_set<std::string> SourcePhrases;
    SourcePhrases m_sourcePhrases;
    PhrasePairRank m_phrasePairRank;
    
    StringVector<unsigned char, unsigned, std::allocator> m_targetSymbols;
    boost::unordered_map<std::string, unsigned> m_targetSymbolsMap;
    
    Hufftree<int, unsigned>* m_symbolTree;
    std::vector<Hufftree<int, float>*> m_scoreTrees;
    Hufftree<int, AlignPoint>* m_alignTree;
    
    // ***********************************************
    
    const std::vector<FactorType>* m_input;
    const std::vector<FactorType>* m_output;
    const PhraseDictionaryFeature* m_feature;
    const std::vector<float>* m_weight;
    float m_weightWP;
    const LMList* m_languageModels;
  
    // ***********************************************
  
    unsigned AddOrGetSourceSymbol(std::string symbol);
    unsigned AddOrGetTargetSymbol(std::string symbol);
    
  public:
    
    std::string GetTargetSymbol(unsigned idx) const;
    size_t getRank(unsigned srcIdx, unsigned trgIdx);
    unsigned getTranslation(unsigned srcIdx, size_t rank);
    
    unsigned encode1(size_t trgIdx);
    unsigned encode2(size_t pos, size_t rank);
    unsigned encode3(unsigned trgIdx);
    unsigned encode4(int left, int right, size_t rank);
    
    size_t getType(unsigned encodedSymbol);
    
    unsigned decodeSymbol1(unsigned encodedSymbol);
    unsigned decodeSymbol2(unsigned encodedSymbol);
    unsigned decodeSymbol3(unsigned encodedSymbol);
    size_t decodeSourcePosition(unsigned encodedSymbol);
    
    struct SrcTrgProbSorter {
      bool operator()(const SrcTrgProb& a, const SrcTrgProb& b) const {
        
        if(a.first.first < b.first.first)
          return true;
        
        // Check impact on translation quality!
        if(a.first.first == b.first.first && a.second > b.second)
          return true;
        
        if(a.first.first == b.first.first
           && a.second == b.second
           && a.first.second < b.first.second
        )
          return true;
        
        return false;
      }
    };
    
    std::set<AlignPoint> packTargetPhraseLex(std::string sourcePhrase,
                                             std::string targetPhrase,
                                             std::string alignment,
                                             std::ostream& os);
    void packTargetPhrase(std::string targetPhrase, std::ostream& os);
    void packScores(std::string scores, std::ostream& os);
    void packScores(std::vector<float>& scores, std::ostream& os);
    void packAlignment(std::string alignment, std::ostream& os);
    void packAlignment(std::set<AlignPoint>& alignment, std::ostream& os);
    
  public:
    typedef std::vector<std::vector<std::string> > StringCollection;
    
    PhraseCoder(
      const std::vector<FactorType>* &input,
      const std::vector<FactorType>* &output,
      const PhraseDictionaryFeature* feature,
      size_t numScoreComponent,
      const std::vector<float>* weight,
      float weightWP,
      const LMList* languageModels
    );
    
    ~PhraseCoder();
    
    void loadLexicalTable(std::string filePath);
    
    size_t load(std::FILE* in);
    size_t save(std::FILE* out);
    
    void calcHuffmanCodes();
    
    void resetCounters();
    
    std::string packCollection(StringCollection collection);
    
    std::string encodePackedCollection(std::string packedCollection);
    
    std::vector<unsigned> unpackSymbols(std::istream& is);
    std::vector<float> unpackScores(std::istream& is);
    std::set<AlignPoint> unpackAlignment(std::istream& is);
    
    template<class Hash, class Container>
    std::string encodePackedCollection(std::vector<std::string>& sourceWords,
      std::string& packedCollection, Hash& h, Container& c) {
      
      std::stringstream packedStream(packedCollection);
      packedStream.unsetf(std::ios::skipws);
      
      std::stringstream encodedPackedStream;
      encodedPackedStream.unsetf(std::ios::skipws);
      
      std::stringstream key;
      key << sourceWords[0];
      for(int i = 0; i < sourceWords.size(); i++)
        key << " " << sourceWords[i];
      
      PhrasePair pp;
      pp.first = key.str();
      m_sourcePhrases.insert(pp.first);
      
      int rank = 0;
      while(packedStream) {
        std::vector<unsigned> symbols = unpackSymbols(packedStream);
        if(symbols.size()) {
          std::vector<float> scores = unpackScores(packedStream); 
          std::set<AlignPoint> alignment = unpackAlignment(packedStream);
          
          encodeAndPackPhrase(encodedPackedStream, sourceWords,
                             symbols, alignment, h, c);
          packScores(scores, encodedPackedStream);
          packAlignment(alignment, encodedPackedStream);
          
          std::stringstream targetPhrase;
          for(int i = 0; i < symbols.size(); i++)
            targetPhrase.write((char*) &(symbols[i]), sizeof(symbols[i]));
          pp.second = targetPhrase.str();
          m_phrasePairRank[pp] = rank;
        }
        rank++;
      }
      
      return encodedPackedStream.str();
    }
    
    template<class Hash, class Container>
    void encodeAndPackPhrase(std::ostream& encodedPackedStream,
      std::vector<std::string>& sourceWords, std::vector<unsigned>& symbols,
      std::set<AlignPoint>& alignment, Hash& h, Container& c) {
      
      unsigned phraseStopSymbol = encode1(AddOrGetTargetSymbol("__SPECIAL_STOP_SYMBOL__"));
      
      //for(int j = 0; j < sourceWords.size(); j++)
      //  std::cerr << sourceWords[j] << " ";
      //std::cerr << "||| ";
      //for(int j = 0; j < symbols.size(); j++)
      //  std::cerr << GetTargetSymbol(symbols[j]) << " ";
      //std::cerr << "||| ";
      //for(int j = 0; j < alignment.size(); j++)
      //  std::cerr << (int)alignment[j].first << "-" << (int)alignment[j].second << " ";
      //std::cerr << std::endl;
      
      std::vector<unsigned> encodedSymbols(symbols.size());
      std::vector<unsigned> encodedSymbolsLengths(symbols.size(), 0);
      
      ConsistantPhrases cp(sourceWords.size(), symbols.size(), alignment.begin(), alignment.end());
      while(cp.size()) {
        ConsistantPhrases::Phrase p = cp.pop();
        //std::cerr << "\t(" << p.i << "," << p.m << "," << p.j << "," << p.n << ")" << std::endl;
        
        std::stringstream key;
        key << sourceWords[p.i];
        for(int i = p.i+1; i < p.i+p.m; i++)
          key << " " << sourceWords[i];

        int rank = getRank(key.str(), symbols.begin() + p.j,
          symbols.begin() + p.j + p.n, h, c);

        if(rank >= 0) {
          unsigned encodedSymbol = encode4(p.i-p.j, sourceWords.size()-(p.i+p.m), rank);
          encodedSymbols[p.j] = encodedSymbol;
          encodedSymbolsLengths[p.j] = p.n;
  
          std::set<AlignPoint> tAlignment;
          for(std::set<AlignPoint>::iterator it = alignment.begin();
              it != alignment.end(); it++)
            if(it->first < p.i || it->first >= p.i + p.m || it->second < p.j
               || it->second >= p.j + p.n)
              tAlignment.insert(*it);
          alignment = tAlignment;
  
          cp.removeOverlap(p);  
        }
      }
      
      int j = 0;
      while(j < symbols.size()) {
        if(encodedSymbolsLengths[j] > 0) {
          unsigned encodedSymbol = encodedSymbols[j];
          encodedPackedStream.write((char*) &encodedSymbol, sizeof(unsigned));
          m_symbolCount[encodedSymbol]++;
          j += encodedSymbolsLengths[j];
        }
        else {
          unsigned encodedSymbol = encode1(symbols[j]);
          encodedPackedStream.write((char*) &encodedSymbol, sizeof(unsigned));
          m_symbolCount[encodedSymbol]++;
          j++;
        }
      }
      
      encodedPackedStream.write((char*) &phraseStopSymbol, sizeof(unsigned));
      m_symbolCount[phraseStopSymbol]++;
    }
    
    template<class TargetIt, class Hash, class Container>
    int getRank(std::string sourcePhrase, TargetIt begin, TargetIt end, Hash& h, Container& c) {
      
      PhrasePair pp;
      pp.first = sourcePhrase;
      if(m_sourcePhrases.count(sourcePhrase)) {
        std::stringstream targetPhrase;
        TargetIt it = begin;
        while(it != end) {
          targetPhrase.write((char*) &(*it), sizeof(*it));
          it++;
        }
        
        pp.second = targetPhrase.str();
        
        if(m_phrasePairRank.count(pp)) {
          //std::cerr << "\tCached " << m_phrasePairRank.size() << std::endl;
          return m_phrasePairRank[pp];
        }
      }
      
      if(m_phrasePairRank.size() > 1000000) {
        m_sourcePhrases.clear();
        m_phrasePairRank.clear();
      }
      
      unsigned idx = h[sourcePhrase];
      if(idx != h.GetSize()) {
        std::stringstream packedStream(c[idx]);
        
        m_sourcePhrases.insert(sourcePhrase);
        
        int rank = 0;
        while(packedStream) {
          std::vector<unsigned> symbols = unpackSymbols(packedStream);
           
          if(symbols.size()) {
            unpackScores(packedStream);
            unpackAlignment(packedStream);
            
            std::stringstream targetPhrase;
            for(int i = 0; i < symbols.size(); i++)
              targetPhrase.write((char*) &(symbols[i]), sizeof(symbols[i]));
            pp.second = targetPhrase.str();
          
            m_phrasePairRank[pp] = rank;
              
            if(symbols.size() == std::distance(begin, end)
               && std::equal(begin, end, symbols.begin()))
              return rank;
            
            rank++;
          }
        }
      }
      
      m_sourcePhrases.insert(sourcePhrase);
      std::stringstream targetPhrase;
      TargetIt it = begin;
      while(it != end) {
        targetPhrase.write((char*) &(*it), sizeof(*it));
        it++;
      }
      pp.second = targetPhrase.str();
      m_phrasePairRank[pp] = -1;
      
      return -1;  
    }
    
    TargetPhraseCollection* decodeCollection(std::string encoded,
                                             const Phrase &sourcePhrase);
    
};

}

#endif